<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
<meta charset="UTF-8"/>
<title>Wanderer</title>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/highlight.js/9.9.0/styles/xcode.min.css"/>
<script
  src="https://cdn.jsdelivr.net/highlight.js/9.9.0/highlight.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/highlight.js/9.9.0/languages/java.min.js"></script>
<script src="highlight.js"></script>
</head>
<body>

<h1>Levels</h1>

<p>The development has reached this point:</p>

<img src="entity.png" alt="The Entity class depending on the Grid class" />

<p>Now we want to add a Level class.  A level object reads in data from a level
file, and acts as a driver for all the non-graphics aspects of the game.</p>

<p>Which way round should the dependencies go?  Should <code>Entity</code>
depend on <code>Level</code>, or vice versa? Either choice is possible, with
some effort.  The choice made here is to have the <code>Entity</code> class
depend on the <code>Level</code> class, and make the <code>Level</code> class a
general framework class:</p>

<img src="levels.png" alt="The Entity class depends on Level which
depends on Grid" />

<p>Besides looking after the grid, one of the things a level object needs to do
is to keep track of global variables such as a score.  But to keep the
<code>Level</code> class general, it should be the entities which change the
global variables, according to their game-specific details.  A generic class
<code>State</code> can be separated off from the <code>Level</code> class to
handle state variables.</p>

<p>Similarly, a level object needs to keep track of a queue of entities, to
control what order they act in.  And again, to keep <code>Level</code> general,
it should be entities which queue themselves up.  A generic <code>Queue</code>
class can be separated out.  That leads us to a picture like this:</p>

<img src="levels2.png" alt="The Entity class depends on Level,
which depends on Grid, State and Queue" />

<p>Despite getting entities to do as much as possible, the level object still
needs to be able to control entities.  To enable this, we can effectively split
the <code>Entity</code> class in two.  Some lifecycle methods can be defined on
entities, to capture what the level object knows about them.  For example,
<code>hatch</code> can be called on each entity after a level has been loaded,
to give it the chance to affect the initial state of the level.  And a method
<code>act</code> can be called on an entity when it is time for it to take one
step of some kind.  These methods can be defined in an interface:</p>

<pre>interface Lifecycle {
    void hatch();
    void act();
    ...
}
</pre>

<p>Then the generic type parameter of the <code>Level</code> class can be
declared to meet this interface:</p>

<pre>class Level&lt;E extends Lifecycle> { ... }
</pre>

<p>And finally the <code>Entity</code> class can implement the interface:</p>

<pre>class Entity implements Lifecycle { ... }
</pre>

<p>Two aspects of the wanderer game are a little unusual.  First, instead of an
entity such as an arrow moving autonomously, it moves by triggering the space in
front of it.  This allows entities to act as stationary booby traps, only
starting to move when the player or another entity moves nearby.  The other
unusual aspect is that the original program used recursion to deal with the way
in which one event triggers another.</p>

<p>For example, if you move near two objects, say an arrow and a boulder, and
set them going, the entire flight of the arrow and everything it triggers,
happens before the boulder moves.  In other words, the program is doing a
depth-first search for things to do.  It is more normal to keep a queue of
things to do, and to use it to give a more concurrent, breadth-first
physics.</p>

<p>The reconstruction uses a double ended queue, and allows entities to be added
at either end.  By adding entities at the start instead of the end, the original
game is reproduced as accurately as possible.</p>

</body>
</html>
